# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    컴퓨터의작동원리.txt                       :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: jasuh <jasuh@student.42seoul.kr>           +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2021/03/30 12:50:42 by jasuh             #+#    #+#              #
#    Updated: 2021/04/08 15:31:04 by jasuh            ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

[컴퓨터작동원리]
	사용자들이 입력장치를 통해 컴퓨터에 명령을 전달해서 출력장치를 통해 결과값을 마주한다. 컴퓨터의 작동원리에 대해 알아
	보자.	

컴퓨터 구성요소
{
	메인보드, 중앙 처리장치, 주 기억장치, 보조 기억장치, 전원공급장치, 입출력장치, 그래픽카드, 디스플레이.


	*중앙 처리장치(Central Processing Unit)


	*주 기억장치(Primary Storage - Computer Memory, Random - Acess Memory, RAM)
		전원을 끄면 데이터가 사라짐. 속도를 위해 해당 특징을 선택함.

	*그래픽스 카드(Graphics Card)
		그래픽스 용도의 GPU와 Memory가 들어있다. 따라서 열을 식혀주기 위한 팬이 있다.
		연산 속도 증가를 위해 필요한 부품.

	*보조 기억장치(Secondary Storage - Computer Memory)
		전원을 꺼도 데이터가 남아있다. 속도가 느리다.
	{
		HDD(Hard Disk Drive)
		물리적으로 움직이는 부품이 안에 들어있다.
		데이터를 읽는 속도가 SSD에 비해  느리다.

		SSD(Solid-State Drive)
		플래쉬 메모리가 발전된 형태.
		디스크가 드라이브되는 형태는 아니라서 빠르다.

		FDD(Floppy Disk Drive)
		HDD와 비슷. 껍데기가 Floppy(기운이 없을 뿐)
		안에 디스크가 있어 운전대처럼 돌면서 운전한다 해서 Drive

		자기테이프(Magnetic Tape)
	}
}

부팅 과정
{
	전원 공급
		글자 그대로 전원 공급
	부트 프로그램 실행
		ROM은(Read Only Memory)
			저장된 메모리만 읽을 수 있다. 쓸 수는 없다. 그래서 CMOS(상보적 금속 산화물 반도체)가 있다.
		BIOS(Basic Input Output System)
			ROM안에 있어 ROM BIOS로 불리기도 한다. 컴퓨터 주변기기 간의 정보전송을 담당하는 프로그램이다.
			하드웨어에 접근하여 제어하므로 펌웨어 성격이 있고 CMOS 셋업 프로그램과 주변기기 초기화, 자체 진단
			루틴도 ROM BIOS에 포함되어 있다. 따라서 BIOS와 CMOS를 구분해서 인식해야 한다.
		CMOS(Complementary Metal-Oxide Semiconductor)
			반도체의 일종. 작은 전지로 전력이 공급. 컴퓨터 전원이 내려가도 데이터가 지워지지 않음.
			사용자가 CMOS에 컴퓨터와 연결된 주변장치들을 저장함으로써 비로소 컴퓨터는 주변기기를 인식 및 제어.
		하드웨어 검사
			하드웨어가 정상인지 컴퓨터에 부착된 기기 중 변경된 내용사항이 있는지 검토한다.
		운영 체제 로드
			보조 기억장치에 저장되어 있는 운영체제를 주기억장치로 복사한다.
		운영 체제 실행
			CPU가 주기억장치를 통해 보조기억장치에 있는 운영체제를 복사해서 실행시킨다.
}

운영체제
{
	운영체제 종류
		UNIX, Linux, Windows, MacOs, iOS, Android
	운영체제의 도입
		과거 하드웨어에를 제어하기 위해 하드웨어 별 소프트웨어를 만들었다. 같은 기능을 하는 하드웨어에 대해 매번 프로그
		램을 만드는 일은 불편하므로 컴퓨터의 공통적인 구성요소를 담당하고 있는 CPU, 주기억 및 보조기억장치 입출력장치를
		제어하기 위한 공통의 프로그램으로 운영체제가 만들어지게 되었다.
	운영체제의 기능
		하드웨어를 제어 또는 하드웨어와 응용프로램을 중개하는 역할을 한다.  
			kernel은 하드웨어를 제어하는 기능을 담당하고 있다.
		여러 프로그램은 같은 CPU, 주기억장치의 자원을 사용하기 때문에 우선 순위가 높은 응용프로그램에 컴퓨터의 자원을 할
		당하는 기능을 수행한다.

}

2진수 사용의 이유 
{	
	컴퓨터가 사용하는 데이터의 특징 
		컴퓨터는 모든 데이터를 숫자로 바꾸어서 처리하는 특징이 있다. 그 때 2진수로 바꿔서 처리한다.
	2진수를 쓰는 이유
		진공관 -> 트랜지스터 -> 집적회로 순으로 개발 되었는데 본질은 전류를 흐르게하거나 흐르지 않게 하는 것에 있다.
		일례로 i7 core의 경우 11억 6000만개의 트랜지스터가 216mm^2에 들어가있다. 즉 전류의 흐름을 조절하는 개수가 이만큼 많다는 것이다.
}

현대적 컴퓨터의 기본 구조
{	
	과거 프로그램의 특징
		과거 plugboard와 punched card는 프로그램은 컴퓨터에 부착해서 사용하는 외장형이었다.
	현대 프로그램의 특징
		현대로 오면서 프로그램은 컴퓨터 안 메모리로 들어가게 되었다.
	폰 노이만 구조
		폰 노이만구조에 의해 컴퓨터는 연산을 하는 부분과 기억을 하는 부분으로 구성되었다.
	폰 노이만 구조에서 발전된 형태
		폰 노이만 구조에서 조금 더 발전해서 CPU, Memory에 추가해서 Input and Output이 생겼다. 
		ex) single system computer bus
}

컴퓨터 메모리의 기본 구조
{
	CPU와 Memroy의 관계
	{
		CPU가 Memory를 오고가며 연산을 수행한다. 자주 사용하는 것은 캐쉬 메모리에 두고 오명가명 연산을 수행한다.

		CPU가 데이터를 Memroy에서 가져올 때와 저장할 때
		{
			CPU가 Memroy는 address bus, control bus, data bus를 통로를 통해 연결되어 있다.
			CPU가 RAM으로부터 데이터를 가져오는 과정
				CPU가 address bus를 통해 RAM에 데이터를 요청. control bus가 enable상태로 활성화. RAM에서 data bus를 통해 CPU로 데이터를 보낸다.
			CPU가 RAM에 데이터를 저장하는 과정
				CPU가 address bus와 data bus를 RAM에 먼저 접근한 후 control bus를 set상태로 활성화시켜서 데이터를 저장하게 된다.
			address bus에 대해서
				Interpreter 언어의 경우 address bus를 알아서 처리해주고 C, C++의 경우 address bus를 설정해주는 특징이 있다.
		}
	순차접근(Sequential access)
		과거 테이프를 재생할 때를 떠올리면 순차 접근을 직관적으로 이해할 수 있다. 앞에서 부터 차례대로 접근하는 것.
	임의접근(Random access) 
		집주소를 찾을 때 주소를 알면 바로 갈 수 있듯이 어디에나 접근할 수 있는 것을 임의접근이라고 한다.
	}
}

CPU의 기본 구조
{
	프로그램이 시작되는 과정
		보조기억장치(HDD, SSD)에 있는 데이터를 주기억장치로 복사해서 CPU가 실행한다.
	CPU가 사용하는 언어
	{
		고수준 프로그래밍 언어
			
		어셈블리 언어
			기계어에서 발전된 언어
		기계어
			0과 1로만 구성된 언어
	}
	CPU 명령어 집합
	{
		ADD
			숫자 두개를 더한다
		COMPARE
			숫자들끼리 비교한다
		IN
			입력장치로부터 정보를 입력받는다
		JUMP
			지정된 메모리 주소로 점프한다
		JUMP IF
			조건에 따라 점프한다
		LOAD
			메모리에서 CPU로 정보를 가져온다
		OUT
			출력 장치로 정보를 출력한다
		STORE
			메모리에 정보를 저장한다
	}
	CPU의 구성요소
	{	
		제어 버스(Control Bus)
		{

			제어장치(Control Unit)
			
			산술 논리 장치 (Arithmetic Logic Unit)
				사칙연산을 한다
			레지스터들(Registers)
			{
				작업공간 역할을한다

				주소 레지스터
				읽고 쓸 메모리 주소 저장

				프로그램 카운터(Program Counter)
				명령어의 메모리 주소 저장. 
				운영체제가 프로그램을 읽은 다음 레지스터에게 명령어의 시작주소를 알려준다.
				PC는 CPU가 실행해야할 명령어의 다음 주소를 저장하고 있다.
		
				명령어 레지스터 
				메모리에서 읽어온 명령어 저장
			
				메모리 주소 레지스터
				프로그램 카운터가 가리키고 있는 주소가 메모리 주소 레지스터에 저장된다.	
			
				메모리 데이터 레지스터
				메모리 주소 레지스터에서 읽어온 데이터 저장한다.
			
				어큐뮬레이터
				연산에 사용되는 데이터 저장
			}
		}
	}
	CPU가 일하는 방법
	{
		A = 3, B = 4, C = A + B라는 연산을 컴퓨터가 실행한다고 했을 때 컴퓨터는 해당 연산을 다음과 같이 인식한다.
		{
			let 3이라는 데이터가 10(A)에 저장되어 있고 4라는 데이터가 11(B)에 저장되어 있다고 하자.
			10번 메모리에 있는 데이터에 11번 메모리에 있는 데이터를 더해서 12번 메모리에 데이터(7)를 저장하는 순으로 연산을 수행한다.
			
			제어 장치(Control Unit), 산술 논리 장치(ALU), 레지스터에서 발생하는 과정
			{	
				LOAD10의 작동 과정
				1. 운영체제가 CPU 내에 있는 레지스터들 중  프로그램 카운터에게 실행할 첫번째 명령의 주소를 알려준다.
				2. '프로그램 카운터'에 있는 메모리 주소가 '메모리 주소 레지스터'로 들어간다.
				3. '메모리 주소 레지스터'에 접근해서 '메모리 데이터 레지스터'에 '메모리 주소 레지스터' 내에 있는 데이터를 넣는다.
				4. '메모리 데이터 레지스터'가 읽어온 데이터의 내용(명령어)를 '명령어 레지스터'로 이동시킨다.
				5. '프로그램 카운터'의 메모리 주소가 변경된다(다음 읽어올 메모리 주소로 변경된다.)
				6. '명령어 레지스터' 내에 있는 명령어가 제어장치(Control Unit)으로 들어간다.
				7. 제어장치에서 해독(decode)한다.
					LOAD  10일 경우 '메모리 주소 레지스터'에 해당 데이터의 주소 10을 넣어주고 '메모리 데이터 레지스터'에 데이터를 갖고온다.
				8. '메모리 데이터 레지스터'내에 있는 데이터가 '어큐뮬레이터'로 들어가게 된다. 메모리 10에 숫자 3이 있을 경우 3이 어큐뮬레이터에 있다.
				-----------------------------------------------------------------------------------------------------------------------------------
				해당 과정까지가 CPU가 어느 메모리 10에 저장되어 있는 명령어 'LOAD 10'을 만났을 때 동작하는 과정이다.
				-----------------------------------------------------------------------------------------------------------------------------------
				ADD 11의 과정
				1. '프로그램 카운터'에 있는 메모리 주소를 '메모리 주소 레지스터'로 이동한다. 
				2. 메모리에 있는 데이터 ADD 11가 '메모리 데이터 레지스터'로 이동한다.
				3. '메모리 데이터 레지스터'의 명령어를 '명령어 레지스터'로 이동한다. '프로그램 카운터' 메모리 주소가 다음 주소로 변경된다.
				4. '명령어 레지스터'에 있는 명령어가 '제어장치'로 이동한다.
				5. '제어장치'에서 명령어를 해독한다. ADD 11의 경우 11번지 메모리 주소에 있는 데이터를 더하라라는 의미이다.
				6. ADD 11을 하기 위해 11번지 메모리 주소를 '메모리 주소 레지스터'에 넣는다. 
				7. 11번지에 있는 데이터를 '메모리 데이터 레지스터'에 넣는다.
				8. 데이터(3)을 어큐뮬레이터로 옮기고 11번지에 있는 데이터(4)가 '어큐뮬레이터' 이동
				9. 해당 데이터(4)가 산술 논리 장치로 가서 계산된다. -> 3 + 4
				10. 계산 결과가 다시 어큐뮬레이터로 이동한다.
				-----------------------------------------------------------------------------------------------------------------------------------
				STORE 12의 과정
				1. 메모리 주소가 '메모리 주소 레지스터'로 이동한다.
				2. 메모리 주소에 있는 데이터가 '메모리 데이터 레지스터'로 이동한다.
				3. '메모리 데이터 레지스터'에 있는 명령어를 '명령어 레지스터'로 이동한다.
				4. 해당 명령어(STORE 12)가 제어장치로 들어간다.
				5. 제어장치에서 명령어를 해독하고 '메모리 주소 레지스터'에 주소 12를 저장한다.
					12번지 메모리에 데이터를 저장하는 명령어이기 때문에 메모리로부터 CPU로 데이터를 가지고 오지 않고 CPU에서 메모리로 데이터를 저장
				6. '어큐뮬레이터'에 있는 계산결과가 '메모리 데이터 레지스터'로 이동하고 메모리 12에 결과 값(7)이 저장된다.
				-----------------------------------------------------------------------------------------------------------------------------------
				프로그램 카운터가 올라가는 시점
				메모리 주소 레지스터 -> 메모리 데이터 레지스터 -> 명령어 레지스터 -> '프로그램 카운터'  이 때 프로그램 카운터 내 메모리가 변경된다.
			}
		}
	}

	정리
	{
		고수준 프로그래밍 언어에서 작성한
		{
			A = 3
			B = 4
			C = A + B
		}
		의 과정이 CPU 내부에선 많은 과정을 거친다는 것을 알아본 시간이었습니다. 
	}
}

정보의 단위
{
	데이터
		현실에서 측정과 관찰을 통해 얻는 값
	정보
		데이터를 처리해서 얻은 값. 유용한 것이 특징

	디지털 데이터와 정보
		컴퓨터에서 사용하는 데이터와 정보
	{
		비트(binary digit)
		전구가 켜졌다 꺼졌다를 나타낼 수 있는 정보의 최소 단위

		1바이트(8 비트)
		메모리 주소의 기본 단위
		8개의 비트는 1 바이트이다.
			
		워드
		CPU가 데이터를 다루는 기본 단위(레지스터의 크기)
		CPU에 따라서 컴퓨터 시스템에 따라서 달라진다. ex) 16비트 워드, 32비트 워드 ...
}

2진수
{
	부호가 있는 8비트 정수
	{
		'-5'를 '8'비트 정수로 표현하기
		{
			1. 5를 2진수로 표현한다.
			2. 2진수'의 보수에 1을 더한다.
				8비트의 첫번째 수가 1이면 -> 음수, 0이면 -> 양수
			숫자 5가 101이고 -5가 11111011이므로 더할 경우 100000000. 8비트 정수이므로 9번째 자리로 올라간 1을 없다고 간주한다.
		}

		2의 보수 표현법에선 0과 -0이 같다
		{
			0의 보수 11111111에 1을 더하면 0이 되기 떄문이다.
		}
		
		2진수 음수를 10진수로 표현하기
		{
			해당 2진수의 보수를 구하고 더하기 1을 해준 뒤 결과 값으로 나온 10진수에 (-)부호룰 붙여준다.
				2진수의 보수를 더하고 1을 더한다 -> 주어진 2진수와의 합이 0인 수를 구하는 행위
				결과 값 10진수에 (-)를 붙인다 -> 주어진 수가 음수이므로 -를 붙여준다.
		}

		보충설명
		{
			8비트의 첫번째 수가 1이면 -> 음수, 0이면 -> 양수
		}
	}

	부호가 없는 정수
	{
		최상위 비트가 부호로 고려되지 않는다.
	}

	8비트 정수의 범위
	{
		signed 정수의 범위
			-128 ~ 127

		unsigned 정수의 범위
			'0' ~ '255'

		특징
			표현할 수 있는 숫자의 개수는 동일하다.
	}
}
